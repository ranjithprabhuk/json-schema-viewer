{"version":3,"file":"index.cjs.js","sources":["../src/nodes/BaseNode.ts","../src/nodes/MirrorNode.ts","../src/accessors/unwrap.ts","../src/nodes/ReferenceNode.ts","../src/utils/pick.ts","../src/accessors/getAnnotations.ts","../src/nodes/types.ts","../src/utils/guards.ts","../src/accessors/getMeta.ts","../src/accessors/guards/isValidType.ts","../src/accessors/getTypes.ts","../src/accessors/inferType.ts","../src/accessors/getValidations.ts","../src/nodes/RegularNode.ts","../src/accessors/getPrimaryType.ts","../src/accessors/getRequired.ts","../src/accessors/getCombiners.ts","../src/accessors/isDeprecated.ts","../src/nodes/RootNode.ts","../src/errors.ts","../src/mergers/mergeAllOf.ts","../src/walker/walk.ts","../src/mergers/mergeOneOrAnyOf.ts","../src/tree/tree.ts","../src/utils/get.ts"],"sourcesContent":["import type { SchemaFragment } from '../types';\nimport type { MirrorNode } from './MirrorNode';\nimport type { RegularNode } from './RegularNode';\nimport type { RootNode } from './RootNode';\n\nlet SEED = 0;\n\nexport abstract class BaseNode {\n  public readonly id: string;\n\n  public parent: RegularNode | RootNode | MirrorNode | null = null;\n  public subpath: string[];\n\n  public get path(): ReadonlyArray<string> {\n    return this.parent === null ? this.subpath : [...this.parent.path, ...this.subpath];\n  }\n\n  public get depth(): number {\n    return this.parent === null ? 0 : this.parent.depth + 1;\n  }\n\n  protected constructor(public readonly fragment: SchemaFragment) {\n    this.id = String(SEED++);\n    this.subpath = [];\n  }\n}\n","import { BaseNode } from './BaseNode';\nimport type { SchemaNode } from './types';\n\nexport class MirrorNode extends BaseNode {\n  constructor(public readonly mirrors: SchemaNode) {\n    super(mirrors.fragment);\n  }\n\n  public get children(): MirrorNode[] | null {\n    if (!('children' in this.mirrors)) return null;\n\n    const referencedChildren = this.mirrors.children;\n    if (referencedChildren === null) return null;\n\n    const children: MirrorNode[] = [];\n    for (const child of referencedChildren) {\n      const mirroredChild = new MirrorNode(child);\n      mirroredChild.parent = this;\n      children.push(mirroredChild);\n    }\n\n    return children;\n  }\n}\n","export function unwrapStringOrNull(value: unknown): string | null {\n  return typeof value === 'string' ? value : null;\n}\n\nexport function unwrapArrayOrNull(value: unknown): unknown[] | null {\n  return Array.isArray(value) ? value : null;\n}\n","import { isLocalRef } from '@stoplight/json';\n\nimport { unwrapStringOrNull } from '../accessors/unwrap';\nimport type { SchemaFragment } from '../types';\nimport { BaseNode } from './BaseNode';\n\nexport class ReferenceNode extends BaseNode {\n  public readonly value: string | null;\n  // public readonly circular: boolean | null; // null = no info\n\n  constructor(fragment: SchemaFragment, public readonly error: string | null) {\n    super(fragment);\n\n    this.value = unwrapStringOrNull(fragment.$ref);\n  }\n\n  public get external() {\n    return this.value !== null && !isLocalRef(this.value);\n  }\n}\n","import type { Dictionary } from '@stoplight/types';\n\nexport function pick(target: Dictionary<unknown>, keys: (string | number)[]) {\n  const source: Dictionary<unknown, string | number> = {};\n\n  for (const key of keys) {\n    if (key in target) {\n      source[key] = target[key];\n    }\n  }\n\n  return source;\n}\n","import type { SchemaAnnotations } from '../nodes/types';\nimport type { SchemaFragment } from '../types';\nimport { pick } from '../utils/pick';\n\nconst ANNOTATIONS: SchemaAnnotations[] = ['description', 'default', 'examples'];\n\nexport function getAnnotations(fragment: SchemaFragment) {\n  return pick(fragment, ANNOTATIONS);\n}\n","import type { MirrorNode } from './MirrorNode';\nimport type { ReferenceNode } from './ReferenceNode';\nimport type { RegularNode } from './RegularNode';\n\nexport type SchemaNode = RegularNode | ReferenceNode | MirrorNode;\n\nexport enum SchemaNodeKind {\n  Any = 'any',\n  String = 'string',\n  Number = 'number',\n  Integer = 'integer',\n  Boolean = 'boolean',\n  Null = 'null',\n  Array = 'array',\n  Object = 'object',\n}\n\nexport enum SchemaCombinerName {\n  AllOf = 'allOf',\n  AnyOf = 'anyOf',\n  OneOf = 'oneOf',\n}\n\nexport type SchemaAnnotations = 'description' | 'default' | 'examples';\n\nexport type SchemaMeta = 'id' | '$schema';\n","import type { Dictionary } from '@stoplight/types';\n\nexport function isStringOrNumber(value: unknown): value is number | string {\n  return typeof value === 'string' || typeof value === 'number';\n}\n\nexport function isObject(maybeObj: unknown): maybeObj is object {\n  return maybeObj !== void 0 && maybeObj !== null && typeof maybeObj === 'object';\n}\n\nexport function isPrimitive(\n  maybePrimitive: unknown,\n): maybePrimitive is string | number | boolean | undefined | null | symbol | bigint {\n  return typeof maybePrimitive !== 'function' && !isObject(maybePrimitive);\n}\n\nexport function isObjectLiteral(maybeObj: unknown): maybeObj is Dictionary<unknown> {\n  if (isPrimitive(maybeObj) === true) return false;\n  const proto = Object.getPrototypeOf(maybeObj);\n  return proto === null || proto === Object.prototype;\n}\n","import type { Dictionary } from '@stoplight/types';\n\nimport type { SchemaMeta } from '../nodes/types';\nimport type { SchemaFragment } from '../types';\nimport { pick } from '../utils';\n\nconst METADATA: SchemaMeta[] = ['id', '$schema'];\n\nexport function getMeta(fragment: SchemaFragment): Partial<Dictionary<unknown, SchemaMeta>> {\n  return pick(fragment, METADATA);\n}\n","import { SchemaNodeKind } from '../../nodes/types';\n\nconst VALID_TYPES = Object.values(SchemaNodeKind);\n\nexport const isValidType = (maybeType: unknown): maybeType is SchemaNodeKind =>\n  typeof maybeType === 'string' && VALID_TYPES.includes(maybeType as SchemaNodeKind);\n","import type { SchemaNodeKind } from '../nodes/types';\nimport type { SchemaFragment } from '../types';\nimport { isValidType } from './guards/isValidType';\nimport { inferType } from './inferType';\n\nexport function getTypes(fragment: SchemaFragment): SchemaNodeKind[] | null {\n  if ('type' in fragment) {\n    if (Array.isArray(fragment.type)) {\n      return fragment.type.filter(isValidType);\n    } else if (isValidType(fragment.type)) {\n      return [fragment.type];\n    }\n  }\n\n  const inferredType = inferType(fragment);\n  if (inferredType !== null) {\n    return [inferredType];\n  }\n\n  return null;\n}\n","import { SchemaNodeKind } from '../nodes/types';\nimport type { SchemaFragment } from '../types';\n\nexport function inferType(fragment: SchemaFragment): SchemaNodeKind | null {\n  if ('properties' in fragment || 'additionalProperties' in fragment || 'patternProperties' in fragment) {\n    return SchemaNodeKind.Object;\n  }\n\n  if ('items' in fragment || 'additionalItems' in fragment) {\n    return SchemaNodeKind.Array;\n  }\n\n  return null;\n}\n","import type { Dictionary } from '@stoplight/types';\nimport type { JSONSchema4 } from 'json-schema';\n\nimport type { SchemaNodeKind } from '../nodes/types';\nimport type { SchemaFragment } from '../types';\nimport { pick } from '../utils/pick';\n\nexport const COMMON_VALIDATION_TYPES: (keyof JSONSchema4)[] = [\n  'default',\n  'example',\n  'nullable',\n  'discriminator',\n  'readOnly',\n  'writeOnly',\n  'xml',\n  'externalDocs',\n];\n\nconst VALIDATION_TYPES: Partial<Dictionary<(keyof JSONSchema4)[], SchemaNodeKind>> = {\n  string: ['minLength', 'maxLength', 'pattern'],\n  number: ['multipleOf', 'minimum', 'exclusiveMinimum', 'maximum', 'exclusiveMaximum'],\n  get integer() {\n    return this.number;\n  },\n  object: ['additionalProperties', 'minProperties', 'maxProperties'],\n  array: ['additionalItems', 'minItems', 'maxItems', 'uniqueItems'],\n};\n\nfunction getTypeValidations(types: SchemaNodeKind[]): (keyof JSONSchema4)[] | null {\n  let extraValidations: (keyof JSONSchema4)[] | null = null;\n\n  for (const type of types) {\n    const value = VALIDATION_TYPES[type];\n    if (value !== void 0) {\n      extraValidations ??= [];\n      extraValidations.push(...value);\n    }\n  }\n\n  return extraValidations;\n}\n\nexport function getValidations(fragment: SchemaFragment, types: SchemaNodeKind[] | null): Dictionary<unknown> {\n  const extraValidations = types === null ? null : getTypeValidations(types);\n\n  return {\n    ...pick(fragment, COMMON_VALIDATION_TYPES),\n    ...(extraValidations !== null ? pick(fragment, extraValidations) : null),\n  };\n}\n","import type { Dictionary } from '@stoplight/types';\n\nimport { getAnnotations } from '../accessors/getAnnotations';\nimport { getCombiners } from '../accessors/getCombiners';\nimport { getMeta } from '../accessors/getMeta';\nimport { getPrimaryType } from '../accessors/getPrimaryType';\nimport { getRequired } from '../accessors/getRequired';\nimport { getTypes } from '../accessors/getTypes';\nimport { getValidations } from '../accessors/getValidations';\nimport { isDeprecated } from '../accessors/isDeprecated';\nimport { unwrapArrayOrNull, unwrapStringOrNull } from '../accessors/unwrap';\nimport type { SchemaFragment } from '../types';\nimport { BaseNode } from './BaseNode';\nimport { SchemaAnnotations, SchemaCombinerName, SchemaMeta, SchemaNode, SchemaNodeKind } from './types';\n\nexport class RegularNode extends BaseNode {\n  public readonly types: SchemaNodeKind[] | null;\n  public readonly primaryType: SchemaNodeKind | null; // object (first choice) or array (second option), primitive last\n  public readonly combiners: SchemaCombinerName[] | null;\n\n  public readonly required: string[] | null;\n  public readonly enum: unknown[] | null; // https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.5.1\n  public readonly format: string | null; // https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-7\n  public readonly title: string | null;\n  public readonly deprecated: boolean;\n\n  public children: SchemaNode[] | null;\n\n  public readonly meta: Readonly<Partial<Dictionary<unknown, SchemaMeta>>>;\n  public readonly annotations: Readonly<Partial<Dictionary<unknown, SchemaAnnotations>>>;\n  public readonly validations: Readonly<Dictionary<unknown>>;\n\n  constructor(public readonly fragment: SchemaFragment) {\n    super(fragment);\n\n    this.types = getTypes(fragment);\n    this.primaryType = getPrimaryType(fragment, this.types);\n    this.combiners = getCombiners(fragment);\n\n    this.deprecated = isDeprecated(fragment);\n    this.enum = unwrapArrayOrNull(fragment.enum);\n    this.required = getRequired(fragment.required);\n    this.format = unwrapStringOrNull(fragment.format);\n    this.title = unwrapStringOrNull(fragment.title);\n\n    this.meta = getMeta(fragment);\n    this.annotations = getAnnotations(fragment);\n    this.validations = getValidations(fragment, this.types);\n\n    this.children = null;\n  }\n\n  public get simple() {\n    return (\n      this.primaryType !== SchemaNodeKind.Array && this.primaryType !== SchemaNodeKind.Object && this.combiners === null\n    );\n  }\n}\n","import { SchemaNodeKind } from '../nodes/types';\nimport type { SchemaFragment } from '../types';\n\nexport function getPrimaryType(fragment: SchemaFragment, types: SchemaNodeKind[] | null) {\n  if (types !== null) {\n    if (types.includes(SchemaNodeKind.Object)) {\n      return SchemaNodeKind.Object;\n    }\n\n    if (types.includes(SchemaNodeKind.Array)) {\n      return SchemaNodeKind.Array;\n    }\n\n    if (types.length > 0) {\n      return types[0];\n    }\n\n    return null;\n  }\n\n  return null;\n}\n","import { isStringOrNumber } from '../utils/guards';\n\nexport function getRequired(required: unknown): string[] | null {\n  if (!Array.isArray(required)) return null;\n  return required.filter(isStringOrNumber).map(String);\n}\n","import { SchemaCombinerName } from '../nodes/types';\nimport type { SchemaFragment } from '../types';\n\nexport function getCombiners(fragment: SchemaFragment): SchemaCombinerName[] | null {\n  let combiners: SchemaCombinerName[] | null = null;\n\n  if (SchemaCombinerName.AnyOf in fragment) {\n    combiners ??= [];\n    combiners.push(SchemaCombinerName.AnyOf);\n  }\n\n  if (SchemaCombinerName.OneOf in fragment) {\n    combiners ??= [];\n    combiners.push(SchemaCombinerName.OneOf);\n  }\n\n  if (SchemaCombinerName.AllOf in fragment) {\n    combiners ??= [];\n    combiners.push(SchemaCombinerName.AllOf);\n  }\n\n  return combiners;\n}\n","import type { SchemaFragment } from '../types';\n\nexport function isDeprecated(fragment: SchemaFragment): boolean {\n  if ('x-deprecated' in fragment) {\n    return fragment['x-deprecated'] === true;\n  }\n\n  if ('deprecated' in fragment) {\n    return fragment.deprecated === true;\n  }\n\n  return false;\n}\n","import type { SchemaFragment } from '../types';\nimport { BaseNode } from './BaseNode';\nimport type { SchemaNode } from './types';\n\nexport class RootNode extends BaseNode {\n  public readonly parent = null;\n  public readonly children: SchemaNode[];\n\n  constructor(public readonly fragment: SchemaFragment) {\n    super(fragment);\n    this.children = [];\n  }\n}\n","export class ResolvingError extends ReferenceError {\n  public readonly name = 'ResolvingError';\n}\n","import { pathToPointer, stringify } from '@stoplight/json';\n\nimport { ResolvingError } from '../errors';\nimport type { SchemaFragment } from '../types';\nimport type { WalkerRefResolver, WalkingOptions } from '../walker/types';\n\nconst resolveAllOf = require('@stoplight/json-schema-merge-allof');\n\nconst store = new WeakMap<WalkerRefResolver, WeakMap<SchemaFragment, string[]>>();\n\nfunction _mergeAllOf(fragment: SchemaFragment, path: string[], resolveRef: WalkerRefResolver | null): SchemaFragment {\n  return resolveAllOf(fragment, {\n    deep: false,\n    resolvers: resolveAllOf.stoplightResolvers,\n    ...(resolveRef !== null\n      ? {\n          $refResolver($ref: unknown) {\n            if (typeof $ref !== 'string') {\n              return {};\n            }\n\n            if (pathToPointer(path).startsWith($ref)) {\n              throw new ResolvingError('Circular reference detected');\n            }\n\n            const allRefs = store.get(resolveRef)!;\n            let schemaRefs = allRefs.get(fragment);\n\n            if (schemaRefs === void 0) {\n              schemaRefs = [$ref];\n              allRefs.set(fragment, schemaRefs);\n            } else if (schemaRefs.includes($ref)) {\n              const safelyResolved = JSON.parse(stringify(resolveRef(null, $ref)));\n              return 'allOf' in safelyResolved ? _mergeAllOf(safelyResolved, path, resolveRef) : safelyResolved;\n            } else {\n              schemaRefs.push($ref);\n            }\n\n            const resolved = resolveRef(null, $ref);\n\n            if (Array.isArray(resolved.allOf)) {\n              for (const member of resolved.allOf) {\n                if (typeof member.$ref === 'string' && schemaRefs.includes(member.$ref)) {\n                  throw new ResolvingError('Circular reference detected');\n                }\n              }\n            }\n\n            return resolved;\n          },\n        }\n      : null),\n  });\n}\n\nexport function mergeAllOf(fragment: SchemaFragment, path: string[], walkingOptions: WalkingOptions) {\n  try {\n    if (walkingOptions.resolveRef !== null && !store.has(walkingOptions.resolveRef)) {\n      store.set(walkingOptions.resolveRef, new WeakMap());\n    }\n\n    return _mergeAllOf(fragment, path, walkingOptions.resolveRef);\n  } catch (ex) {\n    console.info(ex.message);\n    throw ex;\n  }\n}\n","import { EventEmitter } from '@stoplight/lifecycle';\nimport type { Dictionary } from '@stoplight/types';\n\nimport { mergeAllOf } from '../mergers/mergeAllOf';\nimport { mergeOneOrAnyOf } from '../mergers/mergeOneOrAnyOf';\nimport { ReferenceNode, RegularNode } from '../nodes';\nimport { MirrorNode } from '../nodes/MirrorNode';\nimport type { RootNode } from '../nodes/RootNode';\nimport { SchemaCombinerName, SchemaNode, SchemaNodeKind } from '../nodes/types';\nimport type { SchemaFragment } from '../types';\nimport { isObjectLiteral } from '../utils/guards';\nimport type {\n  WalkerEvent,\n  WalkerEventHandler,\n  WalkerHookAction,\n  WalkerHookHandler,\n  WalkerItem,\n  WalkerSnapshot,\n  WalkingOptions,\n} from './types';\n\nexport class Walker extends EventEmitter<Dictionary<WalkerEventHandler, WalkerEvent>> {\n  public readonly path: string[];\n  public depth: number;\n\n  protected fragment: SchemaFragment;\n  protected schemaNode: RegularNode | RootNode;\n\n  private readonly processedFragments: WeakMap<SchemaFragment, SchemaNode>;\n  private readonly hooks: Partial<Dictionary<WalkerHookHandler, WalkerHookAction>>;\n\n  constructor(protected readonly root: RootNode, protected readonly walkingOptions: WalkingOptions) {\n    super();\n\n    this.path = [];\n    this.depth = -1;\n    this.fragment = root.fragment;\n    this.schemaNode = root;\n    this.processedFragments = new WeakMap<SchemaFragment, SchemaNode>();\n\n    this.hooks = {};\n  }\n\n  public *resume(snapshot: WalkerSnapshot) {\n    this.path.splice(0, this.path.length, ...snapshot.path);\n    this.depth = snapshot.depth;\n    this.fragment = snapshot.fragment;\n    this.schemaNode = snapshot.schemaNode;\n\n    yield* this.walk();\n  }\n\n  public pause(): WalkerSnapshot {\n    return {\n      depth: this.depth,\n      fragment: this.fragment,\n      schemaNode: this.schemaNode,\n      path: this.path.slice(),\n    };\n  }\n\n  public hookInto(action: WalkerHookAction, handler: WalkerHookHandler) {\n    this.hooks[action] = handler;\n  }\n\n  public restoreWalkerAtNode(node: RegularNode) {\n    this.path.splice(0, this.path.length, ...node.path);\n    this.depth = node.depth;\n    this.fragment = node.fragment;\n    this.schemaNode = node;\n  }\n\n  public *walk(): IterableIterator<WalkerItem> {\n    const {\n      depth: initialDepth,\n      schemaNode: initialSchemaNode,\n      path: { length },\n    } = this;\n\n    for (const schemaNode of this.processFragment()) {\n      super.emit('newNode', schemaNode);\n\n      this.processedFragments.set(schemaNode.fragment, schemaNode);\n\n      this.fragment = schemaNode.fragment;\n      this.depth = initialDepth + 1;\n\n      const shouldSkipNode = this.hooks.filter?.(schemaNode);\n\n      if (shouldSkipNode === true) {\n        continue;\n      }\n\n      schemaNode.parent = initialSchemaNode;\n      schemaNode.subpath = this.path.slice(initialSchemaNode.path.length);\n\n      if ('children' in initialSchemaNode) {\n        if (initialSchemaNode.children === null) {\n          (initialSchemaNode as RegularNode).children = [schemaNode];\n        } else {\n          initialSchemaNode.children.push(schemaNode);\n        }\n      }\n\n      super.emit('acceptNode', schemaNode);\n\n      if (schemaNode instanceof RegularNode) {\n        this.schemaNode = schemaNode;\n\n        if (this.hooks.stepIn?.(schemaNode) !== false) {\n          super.emit('enterNode', schemaNode);\n          yield* this.walkNodeChildren();\n        }\n      }\n\n      super.emit('exitNode', schemaNode);\n    }\n\n    this.path.length = length;\n    this.depth = initialDepth;\n    this.schemaNode = initialSchemaNode;\n  }\n\n  protected *walkNodeChildren() {\n    const { fragment, schemaNode } = this;\n\n    if (!(schemaNode instanceof RegularNode)) return;\n\n    const {\n      depth: initialDepth,\n      schemaNode: initialSchemaNode,\n      path: { length },\n    } = this;\n\n    if (schemaNode.combiners !== null) {\n      for (const combiner of schemaNode.combiners) {\n        const items = fragment[combiner];\n        if (!Array.isArray(items)) continue;\n\n        let i = -1;\n        for (const item of items) {\n          i++;\n          if (!isObjectLiteral(item)) continue;\n          this.fragment = item;\n          // todo: spaghetti\n          this.schemaNode = initialSchemaNode;\n          this.depth = initialDepth;\n          this.path.length = length;\n          this.path.push(combiner, String(i));\n          yield* this.walk();\n        }\n      }\n    }\n\n    switch (schemaNode.primaryType) {\n      case SchemaNodeKind.Array:\n        if (Array.isArray(fragment.items)) {\n          let i = -1;\n          for (const item of fragment.items) {\n            i++;\n            if (!isObjectLiteral(item)) continue;\n            this.fragment = item;\n            this.schemaNode = initialSchemaNode;\n            this.depth = initialDepth;\n            this.path.length = length;\n            this.path.push('items', String(i));\n            yield* this.walk();\n          }\n        } else if (isObjectLiteral(fragment.items)) {\n          this.schemaNode = initialSchemaNode;\n          this.depth = initialDepth;\n          this.path.length = length;\n          this.fragment = fragment.items;\n          this.path.push('items');\n          yield* this.walk();\n        }\n\n        break;\n      case SchemaNodeKind.Object:\n        if (isObjectLiteral(fragment.properties)) {\n          for (const key of Object.keys(fragment.properties)) {\n            const value = fragment.properties[key];\n            if (!isObjectLiteral(value)) continue;\n            this.fragment = value;\n            this.schemaNode = initialSchemaNode;\n            this.depth = initialDepth;\n            this.path.length = length;\n            this.path.push('properties', key);\n            yield* this.walk();\n          }\n        }\n\n        if (isObjectLiteral(fragment.patternProperties)) {\n          for (const key of Object.keys(fragment.patternProperties)) {\n            const value = fragment.patternProperties[key];\n            if (!isObjectLiteral(value)) continue;\n            this.schemaNode = initialSchemaNode;\n            this.depth = initialDepth;\n            this.path.length = length;\n            this.fragment = value;\n            this.path.push('patternProperties', key);\n            yield* this.walk();\n          }\n        }\n\n        break;\n    }\n\n    this.schemaNode = schemaNode;\n  }\n\n  protected *processFragment(): IterableIterator<SchemaNode> {\n    const { walkingOptions, path, processedFragments } = this;\n    let { fragment } = this;\n\n    const processedFragment = processedFragments.get(fragment);\n    if (processedFragment !== void 0) {\n      return yield new MirrorNode(processedFragment);\n    }\n\n    if ('$ref' in fragment) {\n      if (walkingOptions.resolveRef !== null && typeof fragment.$ref === 'string') {\n        try {\n          fragment = walkingOptions.resolveRef(path, fragment.$ref);\n        } catch (ex) {\n          return yield new ReferenceNode(fragment, ex?.message ?? 'Unknown resolving error');\n        }\n      } else {\n        return yield new ReferenceNode(fragment, null);\n      }\n    }\n\n    if (walkingOptions.mergeAllOf && SchemaCombinerName.AllOf in fragment) {\n      try {\n        fragment = mergeAllOf(fragment, path, walkingOptions);\n      } catch {\n        // no the end of the world - we will render raw unprocessed fragment\n      }\n    }\n\n    if (SchemaCombinerName.OneOf in fragment || SchemaCombinerName.AnyOf in fragment) {\n      try {\n        for (const item of mergeOneOrAnyOf(fragment, path, walkingOptions)) {\n          yield new RegularNode(item);\n        }\n\n        return;\n      } catch {\n        // no the end of the world - we will render raw unprocessed fragment\n      }\n    }\n\n    yield new RegularNode(fragment);\n  }\n}\n","import { SchemaCombinerName } from '../nodes/types';\nimport type { SchemaFragment } from '../types';\nimport type { WalkingOptions } from '../walker/types';\nimport { mergeAllOf } from './mergeAllOf';\n\nexport function mergeOneOrAnyOf(\n  fragment: SchemaFragment,\n  path: string[],\n  walkingOptions: WalkingOptions,\n): SchemaFragment[] {\n  const combiner = SchemaCombinerName.OneOf in fragment ? SchemaCombinerName.OneOf : SchemaCombinerName.AnyOf;\n  const items = fragment[combiner];\n\n  if (!Array.isArray(items)) return []; // just in case\n\n  const merged: SchemaFragment[] = [];\n\n  if (Array.isArray(fragment.allOf) && Array.isArray(items)) {\n    for (const item of items) {\n      merged.push({\n        allOf: [...fragment.allOf, item],\n      });\n    }\n\n    return merged;\n  } else {\n    for (const item of items) {\n      const prunedSchema = { ...fragment };\n      delete prunedSchema[combiner];\n\n      const resolvedItem =\n        typeof item.$ref === 'string' && walkingOptions.resolveRef !== null\n          ? walkingOptions.resolveRef(null, item.$ref)\n          : item;\n\n      if (Object.keys(prunedSchema).length === 0) {\n        merged.push(resolvedItem);\n      } else {\n        const mergedSchema = {\n          allOf: [prunedSchema, resolvedItem],\n        };\n\n        try {\n          merged.push(mergeAllOf(mergedSchema, path, walkingOptions));\n        } catch {\n          merged.push(mergedSchema);\n        }\n      }\n    }\n  }\n\n  return merged;\n}\n","import { extractPointerFromRef, extractSourceFromRef, pointerToPath } from '@stoplight/json';\n\nimport { ResolvingError } from '../errors';\nimport { RootNode } from '../nodes/RootNode';\nimport type { SchemaTreeRefDereferenceFn } from '../resolver/types';\nimport type { SchemaFragment } from '../types';\nimport { isObjectLiteral } from '../utils';\nimport { get } from '../utils/get';\nimport type { WalkerRefResolver } from '../walker/types';\nimport { Walker } from '../walker/walk';\n\nexport type SchemaTreeOptions = {\n  mergeAllOf: boolean;\n  refResolver: SchemaTreeRefDereferenceFn | null;\n};\n\nexport class SchemaTree {\n  public walker: Walker;\n  public root: RootNode;\n\n  constructor(public schema: SchemaFragment, protected readonly opts?: Partial<SchemaTreeOptions>) {\n    this.root = new RootNode(schema);\n    this.walker = new Walker(this.root, {\n      mergeAllOf: this.opts?.mergeAllOf !== false,\n      resolveRef: opts?.refResolver === null ? null : this.resolveRef,\n    });\n  }\n\n  public populate() {\n    this.invokeWalker(this.walker);\n  }\n\n  public invokeWalker(walker: Walker) {\n    const walk = walker.walk();\n    while (!walk.next().done);\n  }\n\n  protected resolveRef: WalkerRefResolver = (path, $ref) => {\n    const seenRefs: string[] = [];\n    let cur$ref: unknown = $ref;\n    let resolvedValue!: SchemaFragment;\n\n    while (typeof cur$ref === 'string') {\n      if (seenRefs.includes(cur$ref)) {\n        break;\n      }\n\n      seenRefs.push(cur$ref);\n      resolvedValue = this._resolveRef(path, cur$ref);\n      cur$ref = resolvedValue.$ref;\n    }\n\n    return resolvedValue;\n  };\n\n  private _resolveRef: WalkerRefResolver = (path, $ref) => {\n    const source = extractSourceFromRef($ref);\n    const pointer = extractPointerFromRef($ref);\n    const { refResolver } = this.opts ?? {};\n\n    if (typeof refResolver === 'function') {\n      return refResolver({ source, pointer }, path, this.schema);\n    } else if (source !== null) {\n      throw new ResolvingError('Cannot dereference external references');\n    } else if (pointer === null) {\n      throw new ResolvingError('The pointer is empty');\n    } else {\n      const value = get(this.schema, pointerToPath(pointer));\n      if (!isObjectLiteral(value)) {\n        throw new ResolvingError('Invalid value');\n      }\n\n      return value;\n    }\n  };\n}\n","import type { Dictionary } from '@stoplight/types';\n\nimport { isObject } from './guards';\n\nexport function get(obj: Dictionary<unknown>, path: (string | number)[]): unknown {\n  if (path.length === 0) {\n    return obj;\n  }\n\n  let curObj: object = obj;\n\n  for (let i = 0; i < path.length - 1; i++) {\n    let segment = path[i];\n\n    curObj = curObj[segment];\n\n    if (!isObject(curObj)) {\n      return;\n    }\n  }\n\n  return curObj[path[path.length - 1]];\n}\n"],"names":["SEED","BaseNode","[object Object]","fragment","this","id","String","subpath","path","parent","depth","MirrorNode","mirrors","super","children","referencedChildren","child","mirroredChild","push","unwrapStringOrNull","value","ReferenceNode","error","$ref","external","isLocalRef","pick","target","keys","source","key","ANNOTATIONS","SchemaNodeKind","SchemaCombinerName","isStringOrNumber","isObject","maybeObj","isObjectLiteral","maybePrimitive","proto","Object","getPrototypeOf","prototype","METADATA","VALID_TYPES","values","isValidType","maybeType","includes","getTypes","Array","isArray","type","filter","inferredType","inferType","COMMON_VALIDATION_TYPES","VALIDATION_TYPES","string","number","integer","object","array","getValidations","types","extraValidations","getTypeValidations","RegularNode","required","primaryType","length","combiners","AnyOf","OneOf","AllOf","getCombiners","deprecated","isDeprecated","enum","map","format","title","meta","getMeta","annotations","getAnnotations","validations","simple","RootNode","ResolvingError","ReferenceError","resolveAllOf","require","store","WeakMap","mergeAllOf","walkingOptions","resolveRef","has","set","_mergeAllOf","deep","resolvers","stoplightResolvers","pathToPointer","startsWith","allRefs","get","schemaRefs","safelyResolved","JSON","parse","stringify","resolved","allOf","member","ex","console","info","message","Walker","EventEmitter","root","schemaNode","processedFragments","hooks","snapshot","splice","walk","slice","action","handler","node","initialDepth","initialSchemaNode","processFragment","emit","stepIn","walkNodeChildren","combiner","items","i","item","properties","patternProperties","processedFragment","merged","prunedSchema","resolvedItem","mergedSchema","mergeOneOrAnyOf","schema","opts","seenRefs","resolvedValue","cur$ref","_resolveRef","extractSourceFromRef","pointer","extractPointerFromRef","refResolver","obj","curObj","pointerToPath","walker","invokeWalker","next","done"],"mappings":"uIAKA,IAAIA,EAAO,QAEWC,EAcpBC,YAAsCC,GAAAC,cAAAD,EAX/BC,YAAqD,KAY1DA,KAAKC,GAAKC,OAAON,KACjBI,KAAKG,QAAU,GAVjBC,WACE,OAAuB,OAAhBJ,KAAKK,OAAkBL,KAAKG,QAAU,IAAIH,KAAKK,OAAOD,QAASJ,KAAKG,SAG7EG,YACE,OAAuB,OAAhBN,KAAKK,OAAkB,EAAIL,KAAKK,OAAOC,MAAQ,SCf7CC,UAAmBV,EAC9BC,YAA4BU,GAC1BC,MAAMD,EAAQT,UADYC,aAAAQ,EAI5BE,eACE,KAAM,aAAcV,KAAKQ,SAAU,OAAO,KAE1C,MAAMG,EAAqBX,KAAKQ,QAAQE,SACxC,GAA2B,OAAvBC,EAA6B,OAAO,KAExC,MAAMD,EAAyB,GAC/B,IAAK,MAAME,KAASD,EAAoB,CACtC,MAAME,EAAgB,IAAIN,EAAWK,GACrCC,EAAcR,OAASL,KACvBU,EAASI,KAAKD,GAGhB,OAAOH,YCrBKK,EAAmBC,GACjC,MAAwB,iBAAVA,EAAqBA,EAAQ,WCKhCC,UAAsBpB,EAIjCC,YAAYC,EAA0CmB,GACpDT,MAAMV,GAD8CC,WAAAkB,EAGpDlB,KAAKgB,MAAQD,EAAmBhB,EAASoB,MAG3CC,eACE,OAAsB,OAAfpB,KAAKgB,QAAmBK,aAAWrB,KAAKgB,iBCfnCM,EAAKC,EAA6BC,GAChD,MAAMC,EAA+C,GAErD,IAAK,MAAMC,KAAOF,EACZE,KAAOH,IACTE,EAAOC,GAAOH,EAAOG,IAIzB,OAAOD,ECPT,MAAME,EAAmC,CAAC,cAAe,UAAW,YCEpE,IAAYC,EAWAC,WCfIC,EAAiBd,GAC/B,MAAwB,iBAAVA,GAAuC,iBAAVA,WAG7Be,EAASC,GACvB,OAAOA,MAAAA,GAAgE,iBAAbA,WAS5CC,EAAgBD,GAC9B,IAA8B,IAJG,mBAFjCE,EAMgBF,KAJgCD,EAASG,IAIrB,OAAO,MAN3CA,EAOA,MAAMC,EAAQC,OAAOC,eAAeL,GACpC,OAAiB,OAAVG,GAAkBA,IAAUC,OAAOE,WDbhCV,EAAAA,yBAAAA,sCAEVA,kBACAA,kBACAA,oBACAA,oBACAA,cACAA,gBACAA,mBAGUC,EAAAA,6BAAAA,8CAEVA,gBACAA,gBEdF,MAAMU,EAAyB,CAAC,KAAM,WCJtC,MAAMC,EAAcJ,OAAOK,OAAOb,wBAErBc,EAAeC,GACL,iBAAdA,GAA0BH,EAAYI,SAASD,YCAxCE,EAAS9C,GACvB,GAAI,SAAUA,EAAU,CACtB,GAAI+C,MAAMC,QAAQhD,EAASiD,MACzB,OAAOjD,EAASiD,KAAKC,OAAOP,GACvB,GAAIA,EAAY3C,EAASiD,MAC9B,MAAO,CAACjD,EAASiD,MAIrB,MAAME,WCXkBnD,GACxB,MAAI,eAAgBA,GAAY,yBAA0BA,GAAY,sBAAuBA,EACpF6B,uBAAeQ,OAGpB,UAAWrC,GAAY,oBAAqBA,EACvC6B,uBAAekB,MAGjB,KDEcK,CAAUpD,GAC/B,OAAqB,OAAjBmD,EACK,CAACA,GAGH,KEZF,MAAME,EAAiD,CAC5D,UACA,UACA,WACA,gBACA,WACA,YACA,MACA,gBAGIC,EAA+E,CACnFC,OAAQ,CAAC,YAAa,YAAa,WACnCC,OAAQ,CAAC,aAAc,UAAW,mBAAoB,UAAW,oBACjEC,cACE,OAAOxD,KAAKuD,QAEdE,OAAQ,CAAC,uBAAwB,gBAAiB,iBAClDC,MAAO,CAAC,kBAAmB,WAAY,WAAY,yBAiBrCC,EAAe5D,EAA0B6D,GACvD,MAAMC,EAA6B,OAAVD,EAAiB,KAf5C,SAA4BA,GAC1B,IAAIC,EAAiD,KAErD,IAAK,MAAMb,KAAQY,EAAO,CACxB,MAAM5C,EAAQqC,EAAiBL,QACjB,IAAVhC,IACF6C,MAAAA,IAAAA,EAAqB,IACrBA,EAAiB/C,QAAQE,IAI7B,OAAO6C,EAI0CC,CAAmBF,GAEpE,sCACKtC,EAAKvB,EAAUqD,IACO,OAArBS,EAA4BvC,EAAKvB,EAAU8D,GAAoB,YChC1DE,UAAoBlE,EAiB/BC,YAA4BC,OC7B2B6D,EZCvB5C,EaFNgD,EF+BxBvD,MAAMV,GADoBC,cAAAD,EAG1BC,KAAK4D,MAAQf,EAAS9C,GACtBC,KAAKiE,YChCO,QADyCL,EDiCT5D,KAAK4D,OC/B7CA,EAAMhB,SAAShB,uBAAeQ,QACzBR,uBAAeQ,OAGpBwB,EAAMhB,SAAShB,uBAAekB,OACzBlB,uBAAekB,MAGpBc,EAAMM,OAAS,EACVN,EAAM,GAGR,KAGF,KDiBL5D,KAAKmE,mBGlCoBpE,GAC3B,IAAIoE,EAAyC,KAiB7C,OAfItC,2BAAmBuC,SAASrE,IAC9BoE,MAAAA,IAAAA,EAAc,IACdA,EAAUrD,KAAKe,2BAAmBuC,QAGhCvC,2BAAmBwC,SAAStE,IAC9BoE,MAAAA,IAAAA,EAAc,IACdA,EAAUrD,KAAKe,2BAAmBwC,QAGhCxC,2BAAmByC,SAASvE,IAC9BoE,MAAAA,IAAAA,EAAc,IACdA,EAAUrD,KAAKe,2BAAmByC,QAG7BH,EHgBYI,CAAaxE,GAE9BC,KAAKwE,oBIrCoBzE,GAC3B,MAAI,iBAAkBA,GACgB,IAA7BA,EAAS,gBAGd,eAAgBA,IACa,IAAxBA,EAASyE,WJ+BEC,CAAa1E,GAC/BC,KAAK0E,MXpCyB1D,EWoCAjB,EAAS2E,KXnClC5B,MAAMC,QAAQ/B,GAASA,EAAQ,MWoCpChB,KAAKgE,UEvCmBA,EFuCIjE,EAASiE,SEtClClB,MAAMC,QAAQiB,GACZA,EAASf,OAAOnB,GAAkB6C,IAAIzE,QADR,MFuCnCF,KAAK4E,OAAS7D,EAAmBhB,EAAS6E,QAC1C5E,KAAK6E,MAAQ9D,EAAmBhB,EAAS8E,OAEzC7E,KAAK8E,cLrCe/E,GACtB,OAAOuB,EAAKvB,EAAUwC,GKoCRwC,CAAQhF,GACpBC,KAAKgF,qBRxCsBjF,GAC7B,OAAOuB,EAAKvB,EAAU4B,GQuCDsD,CAAelF,GAClCC,KAAKkF,YAAcvB,EAAe5D,EAAUC,KAAK4D,OAEjD5D,KAAKU,SAAW,KAGlByE,aACE,OACEnF,KAAKiE,cAAgBrC,uBAAekB,OAAS9C,KAAKiE,cAAgBrC,uBAAeQ,QAA6B,OAAnBpC,KAAKmE,iBKlDzFiB,UAAiBvF,EAI5BC,YAA4BC,GAC1BU,MAAMV,GADoBC,cAAAD,EAHZC,YAAS,KAKvBA,KAAKU,SAAW,UCVP2E,UAAuBC,eAApCxF,kCACkBE,UAAO,kBCKzB,MAAMuF,EAAeC,QAAQ,sCAEvBC,EAAQ,IAAIC,iBA+CFC,EAAW5F,EAA0BK,EAAgBwF,GACnE,IAKE,OAJkC,OAA9BA,EAAeC,YAAwBJ,EAAMK,IAAIF,EAAeC,aAClEJ,EAAMM,IAAIH,EAAeC,WAAY,IAAIH,SAhD/C,SAASM,EAAYjG,EAA0BK,EAAgByF,GAC7D,OAAON,EAAaxF,iBAClBkG,MAAM,EACNC,UAAWX,EAAaY,oBACL,OAAfN,EACA,CACE/F,aAAaqB,GACX,GAAoB,iBAATA,EACT,MAAO,GAGT,GAAIiF,gBAAchG,GAAMiG,WAAWlF,GACjC,MAAM,IAAIkE,EAAe,+BAG3B,MAAMiB,EAAUb,EAAMc,IAAIV,GAC1B,IAAIW,EAAaF,EAAQC,IAAIxG,GAE7B,QAAmB,IAAfyG,EACFA,EAAa,CAACrF,GACdmF,EAAQP,IAAIhG,EAAUyG,OACjB,CAAA,GAAIA,EAAW5D,SAASzB,GAAO,CACpC,MAAMsF,EAAiBC,KAAKC,MAAMC,YAAUf,EAAW,KAAM1E,KAC7D,MAAO,UAAWsF,EAAiBT,EAAYS,EAAgBrG,EAAMyF,GAAcY,EAEnFD,EAAW1F,KAAKK,GAGlB,MAAM0F,EAAWhB,EAAW,KAAM1E,GAElC,GAAI2B,MAAMC,QAAQ8D,EAASC,OACzB,IAAK,MAAMC,KAAUF,EAASC,MAC5B,GAA2B,iBAAhBC,EAAO5F,MAAqBqF,EAAW5D,SAASmE,EAAO5F,MAChE,MAAM,IAAIkE,EAAe,+BAK/B,OAAOwB,IAGX,OAUGb,CAAYjG,EAAUK,EAAMwF,EAAeC,YAClD,MAAOmB,GAEP,MADAC,QAAQC,KAAKF,EAAGG,SACVH,SC3CGI,UAAeC,eAU1BvH,YAA+BwH,EAAmC1B,GAChEnF,QAD6BT,UAAAsH,EAAmCtH,oBAAA4F,EAGhE5F,KAAKI,KAAO,GACZJ,KAAKM,OAAS,EACdN,KAAKD,SAAWuH,EAAKvH,SACrBC,KAAKuH,WAAaD,EAClBtH,KAAKwH,mBAAqB,IAAI9B,QAE9B1F,KAAKyH,MAAQ,GAGR3H,QAAQ4H,GACb1H,KAAKI,KAAKuH,OAAO,EAAG3H,KAAKI,KAAK8D,UAAWwD,EAAStH,MAClDJ,KAAKM,MAAQoH,EAASpH,MACtBN,KAAKD,SAAW2H,EAAS3H,SACzBC,KAAKuH,WAAaG,EAASH,iBAEpBvH,KAAK4H,OAGP9H,QACL,MAAO,CACLQ,MAAON,KAAKM,MACZP,SAAUC,KAAKD,SACfwH,WAAYvH,KAAKuH,WACjBnH,KAAMJ,KAAKI,KAAKyH,SAIb/H,SAASgI,EAA0BC,GACxC/H,KAAKyH,MAAMK,GAAUC,EAGhBjI,oBAAoBkI,GACzBhI,KAAKI,KAAKuH,OAAO,EAAG3H,KAAKI,KAAK8D,UAAW8D,EAAK5H,MAC9CJ,KAAKM,MAAQ0H,EAAK1H,MAClBN,KAAKD,SAAWiI,EAAKjI,SACrBC,KAAKuH,WAAaS,EAGblI,oBACL,MACEQ,MAAO2H,EACPV,WAAYW,EACZ9H,MAAM8D,OAAEA,IACNlE,KAEJ,IAAK,MAAMuH,KAAcvH,KAAKmI,kBAAmB,CAC/C1H,MAAM2H,KAAK,UAAWb,GAEtBvH,KAAKwH,mBAAmBzB,IAAIwB,EAAWxH,SAAUwH,GAEjDvH,KAAKD,SAAWwH,EAAWxH,SAC3BC,KAAKM,MAAQ2H,EAAe,GAIL,kBAFAjI,KAAKyH,OAAMxE,oCAASsE,MAM3CA,EAAWlH,OAAS6H,EACpBX,EAAWpH,QAAUH,KAAKI,KAAKyH,MAAMK,EAAkB9H,KAAK8D,QAExD,aAAcgE,IACmB,OAA/BA,EAAkBxH,SACnBwH,EAAkCxH,SAAW,CAAC6G,GAE/CW,EAAkBxH,SAASI,KAAKyG,IAIpC9G,MAAM2H,KAAK,aAAcb,GAErBA,aAAsBxD,IACxB/D,KAAKuH,WAAaA,GAEsB,kBAApCvH,KAAKyH,OAAMY,oCAASd,MACtB9G,MAAM2H,KAAK,YAAab,SACjBvH,KAAKsI,qBAIhB7H,MAAM2H,KAAK,WAAYb,IAGzBvH,KAAKI,KAAK8D,OAASA,EACnBlE,KAAKM,MAAQ2H,EACbjI,KAAKuH,WAAaW,EAGVpI,oBACR,MAAMC,SAAEA,EAAQwH,WAAEA,GAAevH,KAEjC,KAAMuH,aAAsBxD,GAAc,OAE1C,MACEzD,MAAO2H,EACPV,WAAYW,EACZ9H,MAAM8D,OAAEA,IACNlE,KAEJ,GAA6B,OAAzBuH,EAAWpD,UACb,IAAK,MAAMoE,KAAYhB,EAAWpD,UAAW,CAC3C,MAAMqE,EAAQzI,EAASwI,GACvB,IAAKzF,MAAMC,QAAQyF,GAAQ,SAE3B,IAAIC,GAAK,EACT,IAAK,MAAMC,KAAQF,EACjBC,IACKxG,EAAgByG,KACrB1I,KAAKD,SAAW2I,EAEhB1I,KAAKuH,WAAaW,EAClBlI,KAAKM,MAAQ2H,EACbjI,KAAKI,KAAK8D,OAASA,EACnBlE,KAAKI,KAAKU,KAAKyH,EAAUrI,OAAOuI,UACzBzI,KAAK4H,QAKlB,OAAQL,EAAWtD,aACjB,KAAKrC,uBAAekB,MAClB,GAAIA,MAAMC,QAAQhD,EAASyI,OAAQ,CACjC,IAAIC,GAAK,EACT,IAAK,MAAMC,KAAQ3I,EAASyI,MAC1BC,IACKxG,EAAgByG,KACrB1I,KAAKD,SAAW2I,EAChB1I,KAAKuH,WAAaW,EAClBlI,KAAKM,MAAQ2H,EACbjI,KAAKI,KAAK8D,OAASA,EACnBlE,KAAKI,KAAKU,KAAK,QAASZ,OAAOuI,UACxBzI,KAAK4H,aAEL3F,EAAgBlC,EAASyI,SAClCxI,KAAKuH,WAAaW,EAClBlI,KAAKM,MAAQ2H,EACbjI,KAAKI,KAAK8D,OAASA,EACnBlE,KAAKD,SAAWA,EAASyI,MACzBxI,KAAKI,KAAKU,KAAK,eACRd,KAAK4H,QAGd,MACF,KAAKhG,uBAAeQ,OAClB,GAAIH,EAAgBlC,EAAS4I,YAC3B,IAAK,MAAMjH,KAAOU,OAAOZ,KAAKzB,EAAS4I,YAAa,CAClD,MAAM3H,EAAQjB,EAAS4I,WAAWjH,GAC7BO,EAAgBjB,KACrBhB,KAAKD,SAAWiB,EAChBhB,KAAKuH,WAAaW,EAClBlI,KAAKM,MAAQ2H,EACbjI,KAAKI,KAAK8D,OAASA,EACnBlE,KAAKI,KAAKU,KAAK,aAAcY,SACtB1B,KAAK4H,QAIhB,GAAI3F,EAAgBlC,EAAS6I,mBAC3B,IAAK,MAAMlH,KAAOU,OAAOZ,KAAKzB,EAAS6I,mBAAoB,CACzD,MAAM5H,EAAQjB,EAAS6I,kBAAkBlH,GACpCO,EAAgBjB,KACrBhB,KAAKuH,WAAaW,EAClBlI,KAAKM,MAAQ2H,EACbjI,KAAKI,KAAK8D,OAASA,EACnBlE,KAAKD,SAAWiB,EAChBhB,KAAKI,KAAKU,KAAK,oBAAqBY,SAC7B1B,KAAK4H,SAOpB5H,KAAKuH,WAAaA,EAGVzH,yBACR,MAAM8F,eAAEA,EAAcxF,KAAEA,EAAIoH,mBAAEA,GAAuBxH,KACrD,IAAID,SAAEA,GAAaC,KAEnB,MAAM6I,EAAoBrB,EAAmBjB,IAAIxG,GACjD,QAA0B,IAAtB8I,EACF,aAAa,IAAItI,EAAWsI,GAG9B,GAAI,SAAU9I,EAAU,CACtB,GAAkC,OAA9B6F,EAAeC,YAAgD,iBAAlB9F,EAASoB,KAOxD,aAAa,IAAIF,EAAclB,EAAU,MANzC,IACEA,EAAW6F,EAAeC,WAAWzF,EAAML,EAASoB,MACpD,MAAO6F,GACP,aAAa,IAAI/F,EAAclB,YAAUiH,MAAAA,SAAAA,EAAIG,uBAAW,4BAO9D,GAAIvB,EAAeD,YAAc9D,2BAAmByC,SAASvE,EAC3D,IACEA,EAAW4F,EAAW5F,EAAUK,EAAMwF,GACtC,UAKJ,GAAI/D,2BAAmBwC,SAAStE,GAAY8B,2BAAmBuC,SAASrE,EACtE,IACE,IAAK,MAAM2I,cC5OjB3I,EACAK,EACAwF,GAEA,MAAM2C,EAAW1G,2BAAmBwC,SAAStE,EAAW8B,2BAAmBwC,MAAQxC,2BAAmBuC,MAChGoE,EAAQzI,EAASwI,GAEvB,IAAKzF,MAAMC,QAAQyF,GAAQ,MAAO,GAElC,MAAMM,EAA2B,GAEjC,GAAIhG,MAAMC,QAAQhD,EAAS+G,QAAUhE,MAAMC,QAAQyF,GAAQ,CACzD,IAAK,MAAME,KAAQF,EACjBM,EAAOhI,KAAK,CACVgG,MAAO,IAAI/G,EAAS+G,MAAO4B,KAI/B,OAAOI,EAEP,IAAK,MAAMJ,KAAQF,EAAO,CACxB,MAAMO,mBAAoBhJ,UACnBgJ,EAAaR,GAEpB,MAAMS,EACiB,iBAAdN,EAAKvH,MAAmD,OAA9ByE,EAAeC,WAC5CD,EAAeC,WAAW,KAAM6C,EAAKvH,MACrCuH,EAEN,GAAyC,IAArCtG,OAAOZ,KAAKuH,GAAc7E,OAC5B4E,EAAOhI,KAAKkI,OACP,CACL,MAAMC,EAAe,CACnBnC,MAAO,CAACiC,EAAcC,IAGxB,IACEF,EAAOhI,KAAK6E,EAAWsD,EAAc7I,EAAMwF,IAC3C,SACAkD,EAAOhI,KAAKmI,KAMpB,OAAOH,ED+LkBI,CAAgBnJ,EAAUK,EAAMwF,SAC3C,IAAI7B,EAAY2E,GAGxB,OACA,gBAKE,IAAI3E,EAAYhE,sIExOxBD,YAAmBqJ,EAA2CC,SAA3CpJ,YAAAmJ,EAA2CnJ,UAAAoJ,EAiBpDpJ,gBAAgC,CAACI,EAAMe,KAC/C,MAAMkI,EAAqB,GAC3B,IACIC,EADAC,EAAmBpI,EAGvB,KAA0B,iBAAZoI,IACRF,EAASzG,SAAS2G,IAItBF,EAASvI,KAAKyI,GACdD,EAAgBtJ,KAAKwJ,YAAYpJ,EAAMmJ,GACvCA,EAAUD,EAAcnI,KAG1B,OAAOmI,GAGDtJ,iBAAiC,CAACI,EAAMe,WAC9C,MAAMM,EAASgI,uBAAqBtI,GAC9BuI,EAAUC,wBAAsBxI,IAChCyI,YAAEA,aAAgB5J,KAAKoJ,oBAAQ,GAErC,GAA2B,mBAAhBQ,EACT,OAAOA,EAAY,CAAEnI,OAAAA,EAAQiI,QAAAA,GAAWtJ,EAAMJ,KAAKmJ,QAC9C,GAAe,OAAX1H,EACT,MAAM,IAAI4D,EAAe,0CACpB,GAAgB,OAAZqE,EACT,MAAM,IAAIrE,EAAe,wBACpB,CACL,MAAMrE,WC/DQ6I,EAA0BzJ,GAC5C,GAAoB,IAAhBA,EAAK8D,OACP,OAAO2F,EAGT,IAAIC,EAAiBD,EAErB,IAAK,IAAIpB,EAAI,EAAGA,EAAIrI,EAAK8D,OAAS,EAAGuE,IAAK,CAKxC,GAFAqB,EAASA,EAFK1J,EAAKqI,KAId1G,EAAS+H,GACZ,OAIJ,OAAOA,EAAO1J,EAAKA,EAAK8D,OAAS,ID8CfqC,CAAIvG,KAAKmJ,OAAQY,gBAAcL,IAC7C,IAAKzH,EAAgBjB,GACnB,MAAM,IAAIqE,EAAe,iBAG3B,OAAOrE,IAnDThB,KAAKsH,KAAO,IAAIlC,EAAS+D,GACzBnJ,KAAKgK,OAAS,IAAI5C,EAAOpH,KAAKsH,KAAM,CAClC3B,YAAsC,eAA1B3F,KAAKoJ,2BAAMzD,YACvBE,WAAkC,QAAtBuD,MAAAA,SAAAA,EAAMQ,aAAuB,KAAO5J,KAAK6F,aAIlD/F,WACLE,KAAKiK,aAAajK,KAAKgK,QAGlBlK,aAAakK,GAClB,MAAMpC,EAAOoC,EAAOpC,OACpB,MAAQA,EAAKsC,OAAOC"}